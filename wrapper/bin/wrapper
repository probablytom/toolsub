#!/usr/bin/env bash

# Using gcc's -wrapper option, the compiler driver will invoke
# us instead of cc1, etc., with the full command path as $1.
#
# This file is a basic wrapper script that is designed to be configured or
# extended by a client. In particular, if it finds any of the following variables
# set:
#
# CCWRAP       -- sub-wrapper for bona-fide compilation (not preprocessing) only
# CPPWRAP      -- sub-wrapper for preprocessing only ('cc1' options are rewritten into 'cpp' ones)
# CC1WRAP      -- sub-wrapper for bona-fide compilation (not preprocessing) only, if 'CCWRAP' is not set (FIXME: do we use this? want to eliminate)
# ASWRAP       -- sub-wrapper for assembly
# COLLECT2WRAP -- sub-wrapper for linking via collect2
#
# ... then it will rewrite the invocation of the default tools to
# instead run the given 'sub-wrapper', passing the original command as the first argument.
# Very often these sub-wrappers are implemented as shell functions,  defined by the
# including shell script. However, they can of course also be external commands.
#
# The "original command" can itself be substituted, by setting:
#
# CPP
# CC          (FIXME: not implemented)
# CC1         (FIXME: not implemented, so eliminate)
# AS          (FIXME: implement)
# COLLECT2    (FIXME: implement... probably call it LD)
#
# These variables denote replacement commands; they do not receive a further
# command as their first argument.
#
# If one of the *WRAP variables is set, then when invoking the relevant sub-wrapper,
# the script will substitute the first argument using the relevant variable.
# FIXME: is this feature necessary? Do we use it? Only in dbgcov it seems.
# Let's get rid of it.
#
# If none of the above variables is set, i.e. neither a sub-wrapper nor a substitute
# command is set, then the build should proceed unchanged. Internally, the script will
# be turning 'cc1' invocations back into top-level driver invocations that do a single
# thing at a time, e.g. just preprocess or just compile to assembly, etc.
# In other words, the default for CPP, CC, AS and COLLECT2 (should be LD?)
# is the driver with the relevant single-tool options
#
#   ABOUT collect2: it is used to implement global initialization and destruction
#   in the GNU toolchain, without assuming a loader that supports such features
#   natively. I think any statically linked environment might not?
#   It pulls in __main from libgcc and ensures it has a table of constructors
#   to run. On ELF platforms under static linking, do .ctors and .dtors and .init and .fini
#   and .init_array and .fini_array take effect in the loader? Or is this mechanism
#   i.e. explicit startup code for doing so, needed?
#   Since there is no .dynamic section mandated and no section headers need be present either,
#   I guess it is needed?
#
# SANITY CHECK: how can we use the above to run, say, cilpp -real-cpp '$driver -E' -plugin foo.cmx -fpass-foo ?
# I think so. Run the wrapper with CPP="cilpp -real-cpp \"$CC_DRIVER -E\""
# and the wrapper will set CC_DRIVER as needed. FIXME: who transforms -Wp,BLAH ?
# Also need to provide the stronger property about arg order as documented in cilpp.ml.
#
# Note that in GCC, -no-integrated-cpp no longer does the obvious: even
# if run with -no-integrated-cpp, gcc will not run `cpp' ever... it
# uses cc1 -E. However, for clients that want to intercept just preprocessing,
# -no-integrated-cpp is still important: it prevents a combined preprocess-
# -and-compile cc1 invocation.
#
# If we are symlinked under a name ending '-cflags', '-cppflags',
# '-ldflags' etc, we print out the options that one should pass
# to the compiler for the wrapper to be employed. So you can do
#
# gcc `/path/to/this/file/wrapper-cflags` <... normal gcc args...>
#
# to run with the alternative cpp, and so on.
case "$0" in
    (*cflags|*cppflags|*cxxflags)
        /bin/echo -no-integrated-cpp -wrapper "$(readlink -f "$(dirname "$0")")"/wrapper
        exit 0
    ;;
    (*ldflags)
        # we don't interfere with linking, so no extra ldflags
        exit 0
    ;;
    (*wrapper) # silently continue, i.e. actually act as a "-wrapper wrapper" command
        # FIXME: scrape the driver right here?
    ;;
    (*wrap) # assume the next argument is a driver command, and use -### to interrogate it,
            # i.e. act as a "ccwrap" commad in "ccwrap cc ..." ...
        driver="$1"
        declare -A real_args
        ctr=0
        just_output=0
        while shift; do
            real_args[$ctr]="$1"
            case "$1" in
                ('-###') just_output=1 ;;
                (*) ;;
            esac
            ctr=$(( $ctr + 1 ))
        done
        # Now we need to implement "-wrapper" ourselves, in effect, given a driver $driver
        # that does not support "-wrapper" but does support "-###".
        # What we do next depends on whether "-###" appears in the command already.
        # If it does, we output the command we *would* run.
        # If it doesn't, we actually run them.
        # FIXME: for now, don't support this. Just run them.
        output_stderr="$( "$driver" -\#\#\# "${real_args[@]}" 2>&1 1>&2 )"
        status=$?
        # Every legit command should begin with a space and contain a double quote
        cmdline_filter='^ .*"'
        echo "Got -### output: $output_stderr" 1>&2
        # Did our command actually trigger the "-###" behaviour?
        # If so, we should get at least one line matching "$cmdline_filter"
        # and also a 'Target:' and a 'Thread model:' line. If we don't get these,
        # we assume the compiler did nothing but print some informative output, so
        # we echo that and repeat its return status.
        { grep "$cmdline_filter" <<<"$output_stderr" >/dev/null && \
           grep "^Target:" <<<"$output_stderr" >/dev/null && \
           grep "^Thread model:" <<<"$output_stderr" >/dev/null; } || \
           { echo "Wrapper-degenerated $0" 1>&2; echo "$output_stderr" 1>&2; exit $status; }
        # FIXME: what if we got that output because the -### was already in the command line?
        # Then we still need to wrap -- we need to output the wrapped command.
        # What's our "wrapper" self? Look for an alias of ourselves, in the
        # containing directory, whose name matches "*wrapper"
        our_realpath="$(readlink -f "$0")" #"
        ourselves_as_wrapper="$( ls "$(dirname "$our_realpath")"/*wrapper | while read cand; do
            if [[ "$(realpath "$cand")" == "$our_realpath" ]]; then
                echo "$cand"; break
            fi
        done )"
        if [[ -z "$ourselves_as_wrapper" ]]; then
            echo "Could not identify wrapper alias for $0" 1>&2
            exit 1
        else
            echo "Identified ourselves as wrapper: $ourselves_as_wrapper" 1>&2
        fi
        while read cmdline; do
            if [[ $just_output -eq 1 ]]; then
                echo "$ourselves_as_wrapper" $cmdline 1>&2
                status=0
            else
                echo "REALLY DOING: " "$ourselves_as_wrapper" $cmdline 1>&2
                # NEXT PROBLEM: running 'wrapper' here will cause it to guess
                # the driver incorrectly. It will guess it as *us*, and re-invoke us...
                # but as 'wrapper', so... hmm. What will *that* guess as the driver?
                # Why, us as 'wrapcc'. So we can make the driver-guessing code
                # use ppid->$1 if ppid->$0 looks like a driver-wrapper, or ppid->$0
                # if it looks like a driver. How does it tell the difference? See there.
                #
                # Maybe we just want it to give up on
                # guessing the driver? Since we *know* the driver. Maybe pass it
                # '-driver' explicitly? Feels off. Nicer to use an environment variable?
                export CC_DRIVER="$driver"
                # ... not sure! Maybe -driver is better.
                status=$?
            fi
            if ! [[ $status -eq 0 ]]; then exit $status; fi
        done <<<"$( echo "$output_stderr" | grep "$cmdline_filter" )"
    ;;
    (*) # we're being run as another command -- just being sourced?
    ;;
esac

# Our includer may have already sourced the wrapper funcs so that
# it could use them. If it does, we will have WRAPPER already set.
if [[ -z "$WRAPPER" ]]; then
    . "${WRAPPER_FUNCS:-$(dirname "$0")/../../wrapper/lib/wrapper-funcs.sh}"
fi

debug_print 1 "\$@ is $@" 1>&2

cc1_command_is_pp () {
    local ctr=0
    saw_pp=0
    outpos=0
    doing_m=0
    declare -a seen_args
    while shift; do
        ctr="$(( $ctr + 1 ))"
        seen_args[$ctr]="$1"
        if [[ -z "$1" ]]; then continue; fi
        case "$1" in
         (-o) outfile="$2"; outpos="$(( $ctr + 1 ))";;
         (-M|-MM) doing_m=1 ;;
         (-E) saw_pp=1 ;;
        esac
    done
    # If we didn't see an output file, it might mean that
    # - the default output filename is being used (DOES the driver do this?)
    # - the output is going to stdout, and it's a make rule (-M, -MM)
    # - the output is actual compilation stuff and -pipe is being used?
    # FIXME: support this case once we've seen an example.
    if [ $outpos -eq 0 ] && ! [ $doing_m -eq 1 ]; then
        echo "FIXME: can't work with cc1/cc1plus commands with no output file" 1>&2
        exit 1
    fi
    # if we're only preprocessing, or if we have no explicit output file, just run cc1
    if [ "$saw_pp" -eq 0 ]; then
        debug_print 1 "Wrapping cc1, we don't seem to be doing preprocessing; args ${seen_args[@]}" 1>&2
        false
    else
        debug_print 1 "Wrapping cc1, we seem to be doing a preprocessing step; args ${seen_args[@]}" 1>&2
        true
    fi
}

# In general, we want to run the command that the driver is running.
# But there are some exceptions to do with the C preprocessor.
# In short, to hook preprocessing, although we could wrap the GCC-private
# cc1/cc1plus command, we'd rather wrap the well-documented "cpp"
# command. So we transform a preprocessing cc1/cc1plus call's args into
# args that work for a cpp call.
# FIXME: needs update: we sometimes rewrite to "$driver -E" not "cpp",
# and maybe that's better.
cmd_to_run="$1"
debug_print 1 "cmd_to_run is $cmd_to_run" 1>&2
debug_print 1 "`basename "$cmd_to_run"`-wrapping ($cmd_to_run): $@" 1>&2
case "$cmd_to_run" in
    (*/cc1|*/cc1plus)
        ctr=0
        # if we're only preprocessing, or if we have no explicit output file, just run cc1
        if ! cc1_command_is_pp "$@"; then
            debug_print 1 "Command before cc1-wrapping:" "$@" 1>&2
            shift # we don't need the cc1/cc1plus argument any more
            if [[ -n "$CCWRAP" ]] && expr "$cmd_to_run"  : .*cc1 >/dev/null; then
                # Instead of 'normalizing' cc1 options but then still passing
                # a cc1 command line out to a cc1 wrapper, let's try being
                # consistent with how we wrap 'cpp': rewrite the command line
                # so that it can be passed back through the driver but will
                # only run a single tool. In other words, our clients should
                # never have to worry about the peculiarities of cc1; they should
                # simply wrap the documented cc/cpp/... command lines. Here
                # the 'ccwrap' is always given a '.i-to-.s' job, never doing
                # preprocessing.
                declare -a cc_command
                write_cc_options_from_cc1_command "$cmd_to_run" "$@"
                debug_print 1 "Scraped cc options: [${cc_options[@]}]" 1>&2
                do_exec "$CCWRAP" "${cc_options[@]}"
            else
                if [[ -n "$CC1WRAP" ]]; then
                    # if CC1WRAP is set, e.g. to some function my_cc1, we will use
                    # ${CC1WRAP} $cmd_to_run args...
                    cc1cmd="${CC1WRAP} ${cmd_to_run}"
                else
                    # now if CC1WRAP is still not set, just use what was our $1
                    cc1cmd="${cmd_to_run}"
                fi
                debug_print 1 "Command:" $cc1cmd "$@" 1>&2
                do_exec ${cc1cmd} "$@"
            fi
        else
            debug_print 1 "Command before cpp-wrapping:" "$@" 1>&2
            # convert the cc1/cc1plus options to cpp options
            declare -a cpp_options
            declare -a cc_options
            # Morally, we want to "just call" cpp. But there's a versioning problem
            # with that.  If we just call "cpp" we're not ensuring a preprocessor that
            # is version-matched with the compiler. That matters because, among other
            # things, the default -std=xxx changes over time, but it's essential that
            # the same C standard is used by compiler and preprocessor (and yes, C
            # standard evolution has changed how preprocessing works in some edge cases).
            #
            # Does this mean that our whole schtick of turning a cc1 command back into
            # cpp is flawed? *We* can't know what cpp command to run; only the driver does!
            # So instead we always do $cc -E, for some driver $cc.
            #
            # What does this means for cilpp?
            # Instead of a replacement for cpp, should it be thought of as a replacement
            # for $cc -E?
            # It does no harm having it *also* support standing in for cpp, but
            # the command line is subtly different, and do we ever user that?
            # Probably 'cilpp' should be a wrapper script that translates the command line
            # from 'cpp' form to 'cc -E' form and then calls cilc -E  (better name needed).
            # 'cilc' expects '-E' in its arguments, always runs '$cc -E' for some $cc, and
            # takes '-driver' to allow this to be set explicitly.
            #
            # Instead of running "cpp", we run "$driver -E". Even that is not simple:
            # we must hack around the use of -MD, whose meaning is different on the
            # driver command line than on the cpp command line (see GCC bug 91025).
            #
            #, a cpp-like
            # command line can be assumed by CPPWRAP program.
            #
            # The same "driver" trick is replicated in cilpp's OCaml code, but we pass
            # it the driver as a special "-driver" option, to save it from scraping the
            # parent pid. If a -std=xxx option is given explicitly, this is redundant.
            # We could simplify cilpp by simply guaranteeing to cilpp, or any CPPWRAP
            # program, that we never pass it -MD. However, I want to keep cilpp a generic
            # drop-in(-mostly) replacement, rather than couple it to this wrapper.
            debug_print 1 "CPPWRAP is $CPPWRAP" 1>&2
            debug_print 1 "CPP is $CPP" 1>&2
            declare -a full_cpp_command
            if [[ -n "$CPPWRAP" ]] && [[ -n "$CPP" ]]; then
                full_cpp_command=("${CPPWRAP}" "${CPP}")
                write_cpp_options_from_cc1_command "$@"
                debug_print 1 "Scraped cpp options (1): [${cpp_options[@]}]" 1>&2
                # we've already written cpp_options, above
                full_cpp_command+=("${cpp_options[@]}")
            elif [[ -n "$CPPWRAP" ]]; then
                driver="$(guess_driver)"
                if ! [[ $? -eq 0 ]]; then exit 1; fi
                full_cpp_command=("${CPPWRAP}" "$driver" "-E")
                write_cc_options_from_cc1_command "$@"
                full_cpp_command+=("${cc_options[@]}")
            elif [[ -n "$CPP" ]]; then
                # now if CPPWRAP is still not set, just use cpp
                full_cpp_command=("${CPP}")
                debug_print 1 "Scraped cpp options (3): [${cpp_options[@]}]" 1>&2
                write_cpp_options_from_cc1_command "$@"
                full_cpp_command+=("${cpp_options[@]}") # FIXME: need to skip first arg?
            else
                # now if CPPWRAP is still not set, just use cpp
                driver="$(guess_driver)"
                if ! [[ $? -eq 0 ]]; then exit 1; fi
                full_cpp_command=("$driver" "-E")
                write_cc_options_from_cc1_command "$@"
                debug_print 1 "cc options: ${cc_options[@]}" 1>&2
                full_cpp_command+=("${cc_options[@]}")
            fi
            debug_print 1 "cpp command:" "${full_cpp_command[@]}" 1>&2
            do_exec  "${full_cpp_command[@]}"
        fi
        ;;
    (as|*/as)
        debug_print 1 "command is $@" 1>&2
        orig_as="$1"
        parse_assembler_command "$@"
        shift
        # if ASWRAP is set, use ${ASWRAP} $1
        ASWRAP="${ASWRAP:+${ASWRAP} ${orig_as}}"
        # now if ASWRAP is still not set, just use $1 i.e. run without a wrapper
        ASWRAP="${ASWRAP:-${orig_as}}"
        do_exec ${ASWRAP} "$@"
        ;;
    (collect2|*/collect2)
        # Somehow we want to actually run collect2 but allow wrapping
        # the straight link commands that it would run.
        # See this:
        # https://gcc.gnu.org/onlinedocs/gccint/Collect2.html
        # ... collect2 runs the linker once, then maybe runs it again
        # with an extra (generated) input. Sounds familiar!
        orig_cmd="$1"
        shift
        # if COLLECT2WRAP is set, use ${COLLECT2WRAP} $1
        COLLECT2WRAP="${COLLECT2WRAP:+${COLLECT2WRAP} ${orig_cmd}}"
        # now if COLLECT2WRAP is still not set, just use $1
        COLLECT2WRAP="${COLLECT2WRAP:-${orig_cmd}}"
        do_exec ${COLLECT2WRAP} "$@"
        ;;
    (*) debug_print 1 "Actually not wrapping: $@" 1>&2
        do_exec "$@"
        ;;
esac
